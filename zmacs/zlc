#!/usr/bin/env lua
--
-- Zmacs command generator.
--
-- Copyright (c) 2013 Free Software Foundation, Inc.
--
-- This file is part of GNU Zile.
--
-- This program is free software; you can redistribute it and/or modify it
-- under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3, or (at your option)
-- any later version.
--
-- This program is distributed in the hope that it will be useful, but
-- WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-- General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with this program.  If not, see <http://www.gnu.org/licenses/>.

local getopt = require "std.getopt"
local io     = require "std.io_ext"

local zz   = require "zlisp"
local prog = require "version"



--[[ ======================= ]]--
--[[ ZLisp Command Handlers. ]]--
--[[ ======================= ]]--


-- (defun NAME (PARAM...) DOCSTRING [(interactive)] (function "IMPLEMENTATION"))
-- A special form for describing Zmacs commands.  Each time it is called
-- by Zlisp, output a lua command declaration for binding into Zmacs.
zz.define ("defun",
  function (arglist)
    local params = arglist:nth (2).value

    if params and params.car then
      params = '"' .. params:concat ('", "') .. '"'
    else
      params = ""
    end

    local interactive = arglist:nth (4).value
    local impl
    if interactive.car and interactive.car.value == "interactive" then
      impl = arglist:nth (5).value
      interactive = true
    else
      impl = interactive
      interactive = false
    end

    if type (impl) ~= "string" then
      impl = zz.call_command (impl.car.value, impl.cdr)
    end

    io.write (string.format (
      '\n\nDefun ("%s",\n  {%s},\n[[\n%s\n]],\n  %s,\n  %s\n)\n',
      arglist:nth (1).value, params, arglist:nth (3).value, tostring (interactive), tostring (impl)))
  end
)


zz.define ("lambda",
  function (arglist)
    local params = arglist:nth (1).value

    if params and params.car then
      params = params:concat (", ")
    else
      params = ""
    end

    return string.format ("function (%s)\n    %s\n  end",
      params, arglist:nth (2).value)
  end
)


-- (local NAME (PARAM...) [DOCSTRING] "IMPLEMENTATION")
zz.define ("local",
  function (arglist)
    local params = arglist:nth (2).value
    local impl = arglist:nth (3).value

    if params and params.car then
      params = params:concat (", ")
    else
      params = ""
    end

    io.write ("\n\n")
    if arglist:nth (4) ~= nil then
      io.write ("-- " .. impl:gsub ("\n", "\n-- ") .. "\n")
      impl = arglist:nth (4).value
    end

    io.write (string.format ("local function %s (%s)\n  %s\nend\n",
      arglist:nth (1).value, params, impl))
  end
)


-- (var NAME [DOCSTRING] "INITIAL-VALUE")
zz.define ("var",
  function (arglist)
    local init = arglist:nth (2).value

    io.write ("\n\n")
    if arglist:nth (3) ~= nil then
      io.write ("-- " .. init:gsub ("\n", "\n-- ") .. "\n")
      init = arglist:nth (3).value
    end

    io.write (string.format ("local %s = %s\n", arglist:nth (1).value, init))
  end
)



--[[ =============== ]]--
--[[ Option Parsing. ]]--
--[[ =============== ]]--

prog.banner = prog.version .. "\n" ..
  "Written by Gary V. Vaughan <gary@gnu.org>, 2013\n" ..
  "\n" ..
  prog.COPYRIGHT_STRING .. "\n" ..
  prog.COPYRIGHT_NOTICE .. "\n"

getopt.processArgs (prog)

if #arg == 0 then
  getopt.usage ()
  os.exit (1)
end


-- Preamble.
io.writelines ('-- Generated by ' .. prog.name .. '.',
  '-- ' .. prog.COPYRIGHT_STRING,
  '',
  'lisp = require "eval"',
  'local Defun = lisp.Defun')


-- Treat remaining arguments as filenames to be evaluated by Zlisp.
for i = 1, #arg do
  local ok, errmsg = zz.evalfile (arg[i])
  if not ok then
    errmsg = errmsg or "unknown error"
    io.stderr:write (arg[i] .. ": " .. errmsg .. ".\n")
    os.exit (1)
  end
end
